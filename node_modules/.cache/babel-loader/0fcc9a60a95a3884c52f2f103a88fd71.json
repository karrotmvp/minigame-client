{"ast":null,"code":"/**\n * Zenscroll 4.0.2\n * https://github.com/zengabor/zenscroll/\n *\n * Copyright 2015–2018 Gabor Lenard\n *\n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org>\n * \n */\n\n/*jshint devel:true, asi:true */\n\n/*global define, module */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory());\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    (function install() {\n      // To make sure Zenscroll can be referenced from the header, before `body` is available\n      if (document && document.body) {\n        root.zenscroll = factory();\n      } else {\n        // retry 9ms later\n        setTimeout(install, 9);\n      }\n    })();\n  }\n})(this, function () {\n  \"use strict\"; // Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:\n\n  var isNativeSmoothScrollEnabledOn = function (elem) {\n    return elem && \"getComputedStyle\" in window && window.getComputedStyle(elem)[\"scroll-behavior\"] === \"smooth\";\n  }; // Exit if it’s not a browser environment:\n\n\n  if (typeof window === \"undefined\" || !(\"document\" in window)) {\n    return {};\n  }\n\n  var makeScroller = function (container, defaultDuration, edgeOffset) {\n    // Use defaults if not provided\n    defaultDuration = defaultDuration || 999; //ms\n\n    if (!edgeOffset && edgeOffset !== 0) {\n      // When scrolling, this amount of distance is kept from the edges of the container:\n      edgeOffset = 9; //px\n    } // Handling the life-cycle of the scroller\n\n\n    var scrollTimeoutId;\n\n    var setScrollTimeoutId = function (newValue) {\n      scrollTimeoutId = newValue;\n    };\n    /**\n     * Stop the current smooth scroll operation immediately\n     */\n\n\n    var stopScroll = function () {\n      clearTimeout(scrollTimeoutId);\n      setScrollTimeoutId(0);\n    };\n\n    var getTopWithEdgeOffset = function (elem) {\n      return Math.max(0, container.getTopOf(elem) - edgeOffset);\n    };\n    /**\n     * Scrolls to a specific vertical position in the document.\n     *\n     * @param {targetY} The vertical position within the document.\n     * @param {duration} Optionally the duration of the scroll operation.\n     *        If not provided the default duration is used.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n\n\n    var scrollToY = function (targetY, duration, onDone) {\n      stopScroll();\n\n      if (duration === 0 || duration && duration < 0 || isNativeSmoothScrollEnabledOn(container.body)) {\n        container.toY(targetY);\n\n        if (onDone) {\n          onDone();\n        }\n      } else {\n        var startY = container.getY();\n        var distance = Math.max(0, targetY) - startY;\n        var startTime = new Date().getTime();\n        duration = duration || Math.min(Math.abs(distance), defaultDuration);\n\n        (function loopScroll() {\n          setScrollTimeoutId(setTimeout(function () {\n            // Calculate percentage:\n            var p = Math.min(1, (new Date().getTime() - startTime) / duration); // Calculate the absolute vertical position:\n\n            var y = Math.max(0, Math.floor(startY + distance * (p < 0.5 ? 2 * p * p : p * (4 - p * 2) - 1)));\n            container.toY(y);\n\n            if (p < 1 && container.getHeight() + y < container.body.scrollHeight) {\n              loopScroll();\n            } else {\n              setTimeout(stopScroll, 99); // with cooldown time\n\n              if (onDone) {\n                onDone();\n              }\n            }\n          }, 9));\n        })();\n      }\n    };\n    /**\n     * Scrolls to the top of a specific element.\n     *\n     * @param {elem} The element to scroll to.\n     * @param {duration} Optionally the duration of the scroll operation.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n\n\n    var scrollToElem = function (elem, duration, onDone) {\n      scrollToY(getTopWithEdgeOffset(elem), duration, onDone);\n    };\n    /**\n     * Scrolls an element into view if necessary.\n     *\n     * @param {elem} The element.\n     * @param {duration} Optionally the duration of the scroll operation.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n\n\n    var scrollIntoView = function (elem, duration, onDone) {\n      var elemHeight = elem.getBoundingClientRect().height;\n      var elemBottom = container.getTopOf(elem) + elemHeight;\n      var containerHeight = container.getHeight();\n      var y = container.getY();\n      var containerBottom = y + containerHeight;\n\n      if (getTopWithEdgeOffset(elem) < y || elemHeight + edgeOffset > containerHeight) {\n        // Element is clipped at top or is higher than screen.\n        scrollToElem(elem, duration, onDone);\n      } else if (elemBottom + edgeOffset > containerBottom) {\n        // Element is clipped at the bottom.\n        scrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone);\n      } else if (onDone) {\n        onDone();\n      }\n    };\n    /**\n     * Scrolls to the center of an element.\n     *\n     * @param {elem} The element.\n     * @param {duration} Optionally the duration of the scroll operation.\n     * @param {offset} Optionally the offset of the top of the element from the center of the screen.\n     *        A value of 0 is ignored.\n     * @param {onDone} An optional callback function to be invoked once the scroll finished.\n     */\n\n\n    var scrollToCenterOf = function (elem, duration, offset, onDone) {\n      scrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight() / 2 + (offset || elem.getBoundingClientRect().height / 2)), duration, onDone);\n    };\n    /**\n     * Changes default settings for this scroller.\n     *\n     * @param {newDefaultDuration} Optionally a new value for default duration, used for each scroll method by default.\n     *        Ignored if null or undefined.\n     * @param {newEdgeOffset} Optionally a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.\n     * @returns An object with the current values.\n     */\n\n\n    var setup = function (newDefaultDuration, newEdgeOffset) {\n      if (newDefaultDuration === 0 || newDefaultDuration) {\n        defaultDuration = newDefaultDuration;\n      }\n\n      if (newEdgeOffset === 0 || newEdgeOffset) {\n        edgeOffset = newEdgeOffset;\n      }\n\n      return {\n        defaultDuration: defaultDuration,\n        edgeOffset: edgeOffset\n      };\n    };\n\n    return {\n      setup: setup,\n      to: scrollToElem,\n      toY: scrollToY,\n      intoView: scrollIntoView,\n      center: scrollToCenterOf,\n      stop: stopScroll,\n      moving: function () {\n        return !!scrollTimeoutId;\n      },\n      getY: container.getY,\n      getTopOf: container.getTopOf\n    };\n  };\n\n  var docElem = document.documentElement;\n\n  var getDocY = function () {\n    return window.scrollY || docElem.scrollTop;\n  }; // Create a scroller for the document:\n\n\n  var zenscroll = makeScroller({\n    body: document.scrollingElement || document.body,\n    toY: function (y) {\n      window.scrollTo(0, y);\n    },\n    getY: getDocY,\n    getHeight: function () {\n      return window.innerHeight || docElem.clientHeight;\n    },\n    getTopOf: function (elem) {\n      return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop;\n    }\n  });\n  /**\n   * Creates a scroller from the provided container element (e.g., a DIV)\n   *\n   * @param {scrollContainer} The vertical position within the document.\n   * @param {defaultDuration} Optionally a value for default duration, used for each scroll method by default.\n   *        Ignored if 0 or null or undefined.\n   * @param {edgeOffset} Optionally a value for the edge offset, used by each scroll method by default. \n   *        Ignored if null or undefined.\n   * @returns A scroller object, similar to `zenscroll` but controlling the provided element.\n   */\n\n  zenscroll.createScroller = function (scrollContainer, defaultDuration, edgeOffset) {\n    return makeScroller({\n      body: scrollContainer,\n      toY: function (y) {\n        scrollContainer.scrollTop = y;\n      },\n      getY: function () {\n        return scrollContainer.scrollTop;\n      },\n      getHeight: function () {\n        return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight);\n      },\n      getTopOf: function (elem) {\n        return elem.offsetTop;\n      }\n    }, defaultDuration, edgeOffset);\n  }; // Automatic link-smoothing on achors\n  // Exclude IE8- or when native is enabled or Zenscroll auto- is disabled\n\n\n  if (\"addEventListener\" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {\n    var isHistorySupported = \"history\" in window && \"pushState\" in history;\n    var isScrollRestorationSupported = isHistorySupported && \"scrollRestoration\" in history; // On first load & refresh make sure the browser restores the position first\n\n    if (isScrollRestorationSupported) {\n      history.scrollRestoration = \"auto\";\n    }\n\n    window.addEventListener(\"load\", function () {\n      if (isScrollRestorationSupported) {\n        // Set it to manual\n        setTimeout(function () {\n          history.scrollRestoration = \"manual\";\n        }, 9);\n        window.addEventListener(\"popstate\", function (event) {\n          if (event.state && \"zenscrollY\" in event.state) {\n            zenscroll.toY(event.state.zenscrollY);\n          }\n        }, false);\n      } // Add edge offset on first load if necessary\n      // This may not work on IE (or older computer?) as it requires more timeout, around 100 ms\n\n\n      if (window.location.hash) {\n        setTimeout(function () {\n          // Adjustment is only needed if there is an edge offset:\n          var edgeOffset = zenscroll.setup().edgeOffset;\n\n          if (edgeOffset) {\n            var targetElem = document.getElementById(window.location.href.split(\"#\")[1]);\n\n            if (targetElem) {\n              var targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset);\n              var diff = zenscroll.getY() - targetY; // Only do the adjustment if the browser is very close to the element:\n\n              if (0 <= diff && diff < 9) {\n                window.scrollTo(0, targetY);\n              }\n            }\n          }\n        }, 9);\n      }\n    }, false); // Handling clicks on anchors\n\n    var RE_noZensmooth = new RegExp(\"(^|\\\\s)noZensmooth(\\\\s|$)\");\n    window.addEventListener(\"click\", function (event) {\n      var anchor = event.target;\n\n      while (anchor && anchor.tagName !== \"A\") {\n        anchor = anchor.parentNode;\n      } // Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:\n\n\n      if (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n        return;\n      } // Save the current scrolling position so it can be used for scroll restoration:\n\n\n      if (isScrollRestorationSupported) {\n        var historyState = history.state && typeof history.state === \"object\" ? history.state : {};\n        historyState.zenscrollY = zenscroll.getY();\n\n        try {\n          history.replaceState(historyState, \"\");\n        } catch (e) {// Avoid the Chrome Security exception on file protocol, e.g., file://index.html\n        }\n      } // Find the referenced ID:\n\n\n      var href = anchor.getAttribute(\"href\") || \"\";\n\n      if (href.indexOf(\"#\") === 0 && !RE_noZensmooth.test(anchor.className)) {\n        var targetY = 0;\n        var targetElem = document.getElementById(href.substring(1));\n\n        if (href !== \"#\") {\n          if (!targetElem) {\n            // Let the browser handle the click if the target ID is not found.\n            return;\n          }\n\n          targetY = zenscroll.getTopOf(targetElem);\n        }\n\n        event.preventDefault(); // By default trigger the browser's `hashchange` event...\n\n        var onDone = function () {\n          window.location = href;\n        }; // ...unless there is an edge offset specified\n\n\n        var edgeOffset = zenscroll.setup().edgeOffset;\n\n        if (edgeOffset) {\n          targetY = Math.max(0, targetY - edgeOffset);\n\n          if (isHistorySupported) {\n            onDone = function () {\n              history.pushState({}, \"\", href);\n            };\n          }\n        }\n\n        zenscroll.toY(targetY, null, onDone);\n      }\n    }, false);\n  }\n\n  return zenscroll;\n});","map":{"version":3,"sources":["/Users/jason.ha/Desktop/minigame-karrot-raise-client/node_modules/zenscroll/zenscroll.js"],"names":["root","factory","define","amd","module","exports","install","document","body","zenscroll","setTimeout","isNativeSmoothScrollEnabledOn","elem","window","getComputedStyle","makeScroller","container","defaultDuration","edgeOffset","scrollTimeoutId","setScrollTimeoutId","newValue","stopScroll","clearTimeout","getTopWithEdgeOffset","Math","max","getTopOf","scrollToY","targetY","duration","onDone","toY","startY","getY","distance","startTime","Date","getTime","min","abs","loopScroll","p","y","floor","getHeight","scrollHeight","scrollToElem","scrollIntoView","elemHeight","getBoundingClientRect","height","elemBottom","containerHeight","containerBottom","scrollToCenterOf","offset","setup","newDefaultDuration","newEdgeOffset","to","intoView","center","stop","moving","docElem","documentElement","getDocY","scrollY","scrollTop","scrollingElement","scrollTo","innerHeight","clientHeight","top","offsetTop","createScroller","scrollContainer","noZensmooth","isHistorySupported","history","isScrollRestorationSupported","scrollRestoration","addEventListener","event","state","zenscrollY","location","hash","targetElem","getElementById","href","split","diff","RE_noZensmooth","RegExp","anchor","target","tagName","parentNode","which","shiftKey","metaKey","ctrlKey","altKey","historyState","replaceState","e","getAttribute","indexOf","test","className","substring","preventDefault","pushState"],"mappings":"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","sourcesContent":["/**\n * Zenscroll 4.0.2\n * https://github.com/zengabor/zenscroll/\n *\n * Copyright 2015–2018 Gabor Lenard\n *\n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org>\n * \n */\n\n/*jshint devel:true, asi:true */\n\n/*global define, module */\n\n\n(function (root, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([], factory())\n\t} else if (typeof module === \"object\" && module.exports) {\n\t\tmodule.exports = factory()\n\t} else {\n\t\t(function install() {\n\t\t\t// To make sure Zenscroll can be referenced from the header, before `body` is available\n\t\t\tif (document && document.body) {\n\t\t\t\troot.zenscroll = factory()\n\t\t\t} else {\n\t\t\t\t// retry 9ms later\n\t\t\t\tsetTimeout(install, 9)\n\t\t\t}\n\t\t})()\n\t}\n}(this, function () {\n\t\"use strict\"\n\n\n\t// Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:\n\tvar isNativeSmoothScrollEnabledOn = function (elem) {\n\t\treturn elem && \"getComputedStyle\" in window &&\n\t\t\twindow.getComputedStyle(elem)[\"scroll-behavior\"] === \"smooth\"\n\t}\n\n\n\t// Exit if it’s not a browser environment:\n\tif (typeof window === \"undefined\" || !(\"document\" in window)) {\n\t\treturn {}\n\t}\n\n\n\tvar makeScroller = function (container, defaultDuration, edgeOffset) {\n\n\t\t// Use defaults if not provided\n\t\tdefaultDuration = defaultDuration || 999 //ms\n\t\tif (!edgeOffset && edgeOffset !== 0) {\n\t\t\t// When scrolling, this amount of distance is kept from the edges of the container:\n\t\t\tedgeOffset = 9 //px\n\t\t}\n\n\t\t// Handling the life-cycle of the scroller\n\t\tvar scrollTimeoutId\n\t\tvar setScrollTimeoutId = function (newValue) {\n\t\t\tscrollTimeoutId = newValue\n\t\t}\n\n\t\t/**\n\t\t * Stop the current smooth scroll operation immediately\n\t\t */\n\t\tvar stopScroll = function () {\n\t\t\tclearTimeout(scrollTimeoutId)\n\t\t\tsetScrollTimeoutId(0)\n\t\t}\n\n\t\tvar getTopWithEdgeOffset = function (elem) {\n\t\t\treturn Math.max(0, container.getTopOf(elem) - edgeOffset)\n\t\t}\n\n\t\t/**\n\t\t * Scrolls to a specific vertical position in the document.\n\t\t *\n\t\t * @param {targetY} The vertical position within the document.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t *        If not provided the default duration is used.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollToY = function (targetY, duration, onDone) {\n\t\t\tstopScroll()\n\t\t\tif (duration === 0 || (duration && duration < 0) || isNativeSmoothScrollEnabledOn(container.body)) {\n\t\t\t\tcontainer.toY(targetY)\n\t\t\t\tif (onDone) {\n\t\t\t\t\tonDone()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar startY = container.getY()\n\t\t\t\tvar distance = Math.max(0, targetY) - startY\n\t\t\t\tvar startTime = new Date().getTime()\n\t\t\t\tduration = duration || Math.min(Math.abs(distance), defaultDuration);\n\t\t\t\t(function loopScroll() {\n\t\t\t\t\tsetScrollTimeoutId(setTimeout(function () {\n\t\t\t\t\t\t// Calculate percentage:\n\t\t\t\t\t\tvar p = Math.min(1, (new Date().getTime() - startTime) / duration)\n\t\t\t\t\t\t// Calculate the absolute vertical position:\n\t\t\t\t\t\tvar y = Math.max(0, Math.floor(startY + distance*(p < 0.5 ? 2*p*p : p*(4 - p*2)-1)))\n\t\t\t\t\t\tcontainer.toY(y)\n\t\t\t\t\t\tif (p < 1 && (container.getHeight() + y) < container.body.scrollHeight) {\n\t\t\t\t\t\t\tloopScroll()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetTimeout(stopScroll, 99) // with cooldown time\n\t\t\t\t\t\t\tif (onDone) {\n\t\t\t\t\t\t\t\tonDone()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 9))\n\t\t\t\t})()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Scrolls to the top of a specific element.\n\t\t *\n\t\t * @param {elem} The element to scroll to.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollToElem = function (elem, duration, onDone) {\n\t\t\tscrollToY(getTopWithEdgeOffset(elem), duration, onDone)\n\t\t}\n\n\t\t/**\n\t\t * Scrolls an element into view if necessary.\n\t\t *\n\t\t * @param {elem} The element.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollIntoView = function (elem, duration, onDone) {\n\t\t\tvar elemHeight = elem.getBoundingClientRect().height\n\t\t\tvar elemBottom = container.getTopOf(elem) + elemHeight\n\t\t\tvar containerHeight = container.getHeight()\n\t\t\tvar y = container.getY()\n\t\t\tvar containerBottom = y + containerHeight\n\t\t\tif (getTopWithEdgeOffset(elem) < y || (elemHeight + edgeOffset) > containerHeight) {\n\t\t\t\t// Element is clipped at top or is higher than screen.\n\t\t\t\tscrollToElem(elem, duration, onDone)\n\t\t\t} else if ((elemBottom + edgeOffset) > containerBottom) {\n\t\t\t\t// Element is clipped at the bottom.\n\t\t\t\tscrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone)\n\t\t\t} else if (onDone) {\n\t\t\t\tonDone()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Scrolls to the center of an element.\n\t\t *\n\t\t * @param {elem} The element.\n\t\t * @param {duration} Optionally the duration of the scroll operation.\n\t\t * @param {offset} Optionally the offset of the top of the element from the center of the screen.\n\t\t *        A value of 0 is ignored.\n\t\t * @param {onDone} An optional callback function to be invoked once the scroll finished.\n\t\t */\n\t\tvar scrollToCenterOf = function (elem, duration, offset, onDone) {\n\t\t\tscrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight()/2 + (offset || elem.getBoundingClientRect().height/2)), duration, onDone)\n\t\t}\n\n\t\t/**\n\t\t * Changes default settings for this scroller.\n\t\t *\n\t\t * @param {newDefaultDuration} Optionally a new value for default duration, used for each scroll method by default.\n\t\t *        Ignored if null or undefined.\n\t\t * @param {newEdgeOffset} Optionally a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.\n\t\t * @returns An object with the current values.\n\t\t */\n\t\tvar setup = function (newDefaultDuration, newEdgeOffset) {\n\t\t\tif (newDefaultDuration === 0 || newDefaultDuration) {\n\t\t\t\tdefaultDuration = newDefaultDuration\n\t\t\t}\n\t\t\tif (newEdgeOffset === 0 || newEdgeOffset) {\n\t\t\t\tedgeOffset = newEdgeOffset\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tdefaultDuration: defaultDuration,\n\t\t\t\tedgeOffset: edgeOffset\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\tto: scrollToElem,\n\t\t\ttoY: scrollToY,\n\t\t\tintoView: scrollIntoView,\n\t\t\tcenter: scrollToCenterOf,\n\t\t\tstop: stopScroll,\n\t\t\tmoving: function () { return !!scrollTimeoutId },\n\t\t\tgetY: container.getY,\n\t\t\tgetTopOf: container.getTopOf\n\t\t}\n\n\t}\n\n\n\tvar docElem = document.documentElement\n\tvar getDocY = function () { return window.scrollY || docElem.scrollTop }\n\n\t// Create a scroller for the document:\n\tvar zenscroll = makeScroller({\n\t\tbody: document.scrollingElement || document.body,\n\t\ttoY: function (y) { window.scrollTo(0, y) },\n\t\tgetY: getDocY,\n\t\tgetHeight: function () { return window.innerHeight || docElem.clientHeight },\n\t\tgetTopOf: function (elem) { return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop }\n\t})\n\n\n\t/**\n\t * Creates a scroller from the provided container element (e.g., a DIV)\n\t *\n\t * @param {scrollContainer} The vertical position within the document.\n\t * @param {defaultDuration} Optionally a value for default duration, used for each scroll method by default.\n\t *        Ignored if 0 or null or undefined.\n\t * @param {edgeOffset} Optionally a value for the edge offset, used by each scroll method by default. \n\t *        Ignored if null or undefined.\n\t * @returns A scroller object, similar to `zenscroll` but controlling the provided element.\n\t */\n\tzenscroll.createScroller = function (scrollContainer, defaultDuration, edgeOffset) {\n\t\treturn makeScroller({\n\t\t\tbody: scrollContainer,\n\t\t\ttoY: function (y) { scrollContainer.scrollTop = y },\n\t\t\tgetY: function () { return scrollContainer.scrollTop },\n\t\t\tgetHeight: function () { return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight) },\n\t\t\tgetTopOf: function (elem) { return elem.offsetTop }\n\t\t}, defaultDuration, edgeOffset)\n\t}\n\n\n\t// Automatic link-smoothing on achors\n\t// Exclude IE8- or when native is enabled or Zenscroll auto- is disabled\n\tif (\"addEventListener\" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {\n\n\t\tvar isHistorySupported = \"history\" in window && \"pushState\" in history\n\t\tvar isScrollRestorationSupported = isHistorySupported && \"scrollRestoration\" in history\n\n\t\t// On first load & refresh make sure the browser restores the position first\n\t\tif (isScrollRestorationSupported) {\n\t\t\thistory.scrollRestoration = \"auto\"\n\t\t}\n\n\t\twindow.addEventListener(\"load\", function () {\n\n\t\t\tif (isScrollRestorationSupported) {\n\t\t\t\t// Set it to manual\n\t\t\t\tsetTimeout(function () { history.scrollRestoration = \"manual\" }, 9)\n\t\t\t\twindow.addEventListener(\"popstate\", function (event) {\n\t\t\t\t\tif (event.state && \"zenscrollY\" in event.state) {\n\t\t\t\t\t\tzenscroll.toY(event.state.zenscrollY)\n\t\t\t\t\t}\n\t\t\t\t}, false)\n\t\t\t}\n\n\t\t\t// Add edge offset on first load if necessary\n\t\t\t// This may not work on IE (or older computer?) as it requires more timeout, around 100 ms\n\t\t\tif (window.location.hash) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t// Adjustment is only needed if there is an edge offset:\n\t\t\t\t\tvar edgeOffset = zenscroll.setup().edgeOffset\n\t\t\t\t\tif (edgeOffset) {\n\t\t\t\t\t\tvar targetElem = document.getElementById(window.location.href.split(\"#\")[1])\n\t\t\t\t\t\tif (targetElem) {\n\t\t\t\t\t\t\tvar targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset)\n\t\t\t\t\t\t\tvar diff = zenscroll.getY() - targetY\n\t\t\t\t\t\t\t// Only do the adjustment if the browser is very close to the element:\n\t\t\t\t\t\t\tif (0 <= diff && diff < 9 ) {\n\t\t\t\t\t\t\t\twindow.scrollTo(0, targetY)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 9)\n\t\t\t}\n\n\t\t}, false)\n\n\t\t// Handling clicks on anchors\n\t\tvar RE_noZensmooth = new RegExp(\"(^|\\\\s)noZensmooth(\\\\s|$)\")\n\t\twindow.addEventListener(\"click\", function (event) {\n\t\t\tvar anchor = event.target\n\t\t\twhile (anchor && anchor.tagName !== \"A\") {\n\t\t\t\tanchor = anchor.parentNode\n\t\t\t}\n\t\t\t// Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:\n\t\t\tif (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Save the current scrolling position so it can be used for scroll restoration:\n\t\t\tif (isScrollRestorationSupported) {\n\t\t\t\tvar historyState = history.state && typeof history.state === \"object\" ? history.state : {}\n\t\t\t\thistoryState.zenscrollY = zenscroll.getY()\n\t\t\t\ttry {\n\t\t\t\t\thistory.replaceState(historyState, \"\")\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Avoid the Chrome Security exception on file protocol, e.g., file://index.html\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Find the referenced ID:\n\t\t\tvar href = anchor.getAttribute(\"href\") || \"\"\n\t\t\tif (href.indexOf(\"#\") === 0 && !RE_noZensmooth.test(anchor.className)) {\n\t\t\t\tvar targetY = 0\n\t\t\t\tvar targetElem = document.getElementById(href.substring(1))\n\t\t\t\tif (href !== \"#\") {\n\t\t\t\t\tif (!targetElem) {\n\t\t\t\t\t\t// Let the browser handle the click if the target ID is not found.\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\ttargetY = zenscroll.getTopOf(targetElem)\n\t\t\t\t}\n\t\t\t\tevent.preventDefault()\n\t\t\t\t// By default trigger the browser's `hashchange` event...\n\t\t\t\tvar onDone = function () { window.location = href }\n\t\t\t\t// ...unless there is an edge offset specified\n\t\t\t\tvar edgeOffset = zenscroll.setup().edgeOffset\n\t\t\t\tif (edgeOffset) {\n\t\t\t\t\ttargetY = Math.max(0, targetY - edgeOffset)\n\t\t\t\t\tif (isHistorySupported) {\n\t\t\t\t\t\tonDone = function () { history.pushState({}, \"\", href) }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzenscroll.toY(targetY, null, onDone)\n\t\t\t}\n\t\t}, false)\n\n\t}\n\n\n\treturn zenscroll\n\n\n}));\n"]},"metadata":{},"sourceType":"script"}